// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: unittest.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_unittest_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_unittest_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_unittest_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_unittest_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace webrtc {
namespace audioproc {
class OutputData;
class OutputDataDefaultTypeInternal;
extern OutputDataDefaultTypeInternal _OutputData_default_instance_;
class Test;
class TestDefaultTypeInternal;
extern TestDefaultTypeInternal _Test_default_instance_;
class Test_DelayMetrics;
class Test_DelayMetricsDefaultTypeInternal;
extern Test_DelayMetricsDefaultTypeInternal _Test_DelayMetrics_default_instance_;
class Test_EchoMetrics;
class Test_EchoMetricsDefaultTypeInternal;
extern Test_EchoMetricsDefaultTypeInternal _Test_EchoMetrics_default_instance_;
class Test_Frame;
class Test_FrameDefaultTypeInternal;
extern Test_FrameDefaultTypeInternal _Test_Frame_default_instance_;
}  // namespace audioproc
}  // namespace webrtc
PROTOBUF_NAMESPACE_OPEN
template<> ::webrtc::audioproc::OutputData* Arena::CreateMaybeMessage<::webrtc::audioproc::OutputData>(Arena*);
template<> ::webrtc::audioproc::Test* Arena::CreateMaybeMessage<::webrtc::audioproc::Test>(Arena*);
template<> ::webrtc::audioproc::Test_DelayMetrics* Arena::CreateMaybeMessage<::webrtc::audioproc::Test_DelayMetrics>(Arena*);
template<> ::webrtc::audioproc::Test_EchoMetrics* Arena::CreateMaybeMessage<::webrtc::audioproc::Test_EchoMetrics>(Arena*);
template<> ::webrtc::audioproc::Test_Frame* Arena::CreateMaybeMessage<::webrtc::audioproc::Test_Frame>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace webrtc {
namespace audioproc {

// ===================================================================

class Test_Frame :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.Test.Frame) */ {
 public:
  Test_Frame();
  virtual ~Test_Frame();

  Test_Frame(const Test_Frame& from);
  Test_Frame(Test_Frame&& from) noexcept
    : Test_Frame() {
    *this = ::std::move(from);
  }

  inline Test_Frame& operator=(const Test_Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Test_Frame& operator=(Test_Frame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Test_Frame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Test_Frame* internal_default_instance() {
    return reinterpret_cast<const Test_Frame*>(
               &_Test_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Test_Frame& a, Test_Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Test_Frame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Test_Frame* New() const final {
    return CreateMaybeMessage<Test_Frame>(nullptr);
  }

  Test_Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Test_Frame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Test_Frame& from);
  void MergeFrom(const Test_Frame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Test_Frame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audioproc.Test.Frame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test.Frame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_unittest_2eproto;
};
// -------------------------------------------------------------------

class Test_EchoMetrics :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.Test.EchoMetrics) */ {
 public:
  Test_EchoMetrics();
  virtual ~Test_EchoMetrics();

  Test_EchoMetrics(const Test_EchoMetrics& from);
  Test_EchoMetrics(Test_EchoMetrics&& from) noexcept
    : Test_EchoMetrics() {
    *this = ::std::move(from);
  }

  inline Test_EchoMetrics& operator=(const Test_EchoMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Test_EchoMetrics& operator=(Test_EchoMetrics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Test_EchoMetrics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Test_EchoMetrics* internal_default_instance() {
    return reinterpret_cast<const Test_EchoMetrics*>(
               &_Test_EchoMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Test_EchoMetrics& a, Test_EchoMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(Test_EchoMetrics* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Test_EchoMetrics* New() const final {
    return CreateMaybeMessage<Test_EchoMetrics>(nullptr);
  }

  Test_EchoMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Test_EchoMetrics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Test_EchoMetrics& from);
  void MergeFrom(const Test_EchoMetrics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Test_EchoMetrics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audioproc.Test.EchoMetrics";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEchoReturnLossFieldNumber = 1,
    kEchoReturnLossEnhancementFieldNumber = 2,
    kDivergentFilterFractionFieldNumber = 3,
    kResidualEchoLikelihoodFieldNumber = 4,
    kResidualEchoLikelihoodRecentMaxFieldNumber = 5,
  };
  // optional float echo_return_loss = 1;
  bool has_echo_return_loss() const;
  void clear_echo_return_loss();
  float echo_return_loss() const;
  void set_echo_return_loss(float value);

  // optional float echo_return_loss_enhancement = 2;
  bool has_echo_return_loss_enhancement() const;
  void clear_echo_return_loss_enhancement();
  float echo_return_loss_enhancement() const;
  void set_echo_return_loss_enhancement(float value);

  // optional float divergent_filter_fraction = 3;
  bool has_divergent_filter_fraction() const;
  void clear_divergent_filter_fraction();
  float divergent_filter_fraction() const;
  void set_divergent_filter_fraction(float value);

  // optional float residual_echo_likelihood = 4;
  bool has_residual_echo_likelihood() const;
  void clear_residual_echo_likelihood();
  float residual_echo_likelihood() const;
  void set_residual_echo_likelihood(float value);

  // optional float residual_echo_likelihood_recent_max = 5;
  bool has_residual_echo_likelihood_recent_max() const;
  void clear_residual_echo_likelihood_recent_max();
  float residual_echo_likelihood_recent_max() const;
  void set_residual_echo_likelihood_recent_max(float value);

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test.EchoMetrics)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float echo_return_loss_;
  float echo_return_loss_enhancement_;
  float divergent_filter_fraction_;
  float residual_echo_likelihood_;
  float residual_echo_likelihood_recent_max_;
  friend struct ::TableStruct_unittest_2eproto;
};
// -------------------------------------------------------------------

class Test_DelayMetrics :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.Test.DelayMetrics) */ {
 public:
  Test_DelayMetrics();
  virtual ~Test_DelayMetrics();

  Test_DelayMetrics(const Test_DelayMetrics& from);
  Test_DelayMetrics(Test_DelayMetrics&& from) noexcept
    : Test_DelayMetrics() {
    *this = ::std::move(from);
  }

  inline Test_DelayMetrics& operator=(const Test_DelayMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Test_DelayMetrics& operator=(Test_DelayMetrics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Test_DelayMetrics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Test_DelayMetrics* internal_default_instance() {
    return reinterpret_cast<const Test_DelayMetrics*>(
               &_Test_DelayMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Test_DelayMetrics& a, Test_DelayMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(Test_DelayMetrics* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Test_DelayMetrics* New() const final {
    return CreateMaybeMessage<Test_DelayMetrics>(nullptr);
  }

  Test_DelayMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Test_DelayMetrics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Test_DelayMetrics& from);
  void MergeFrom(const Test_DelayMetrics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Test_DelayMetrics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audioproc.Test.DelayMetrics";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMedianFieldNumber = 1,
    kStdFieldNumber = 2,
  };
  // optional int32 median = 1;
  bool has_median() const;
  void clear_median();
  ::PROTOBUF_NAMESPACE_ID::int32 median() const;
  void set_median(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 std = 2;
  bool has_std() const;
  void clear_std();
  ::PROTOBUF_NAMESPACE_ID::int32 std() const;
  void set_std(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test.DelayMetrics)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 median_;
  ::PROTOBUF_NAMESPACE_ID::int32 std_;
  friend struct ::TableStruct_unittest_2eproto;
};
// -------------------------------------------------------------------

class Test :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.Test) */ {
 public:
  Test();
  virtual ~Test();

  Test(const Test& from);
  Test(Test&& from) noexcept
    : Test() {
    *this = ::std::move(from);
  }

  inline Test& operator=(const Test& from) {
    CopyFrom(from);
    return *this;
  }
  inline Test& operator=(Test&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Test& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Test* internal_default_instance() {
    return reinterpret_cast<const Test*>(
               &_Test_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Test& a, Test& b) {
    a.Swap(&b);
  }
  inline void Swap(Test* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Test* New() const final {
    return CreateMaybeMessage<Test>(nullptr);
  }

  Test* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Test>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Test& from);
  void MergeFrom(const Test& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Test* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audioproc.Test";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Test_Frame Frame;
  typedef Test_EchoMetrics EchoMetrics;
  typedef Test_DelayMetrics DelayMetrics;

  // accessors -------------------------------------------------------

  enum : int {
    kFrameFieldNumber = 5,
    kEchoMetricsFieldNumber = 11,
    kDelayMetricsFieldNumber = 12,
    kNumReverseChannelsFieldNumber = 1,
    kNumInputChannelsFieldNumber = 2,
    kNumOutputChannelsFieldNumber = 3,
    kSampleRateFieldNumber = 4,
    kAnalogLevelAverageFieldNumber = 6,
    kMaxOutputAverageFieldNumber = 7,
    kHasVoiceCountFieldNumber = 9,
    kIsSaturatedCountFieldNumber = 10,
    kRmsDbfsAverageFieldNumber = 13,
    kNsSpeechProbabilityAverageFieldNumber = 14,
    kUseAecExtendedFilterFieldNumber = 15,
  };
  // repeated .webrtc.audioproc.Test.Frame frame = 5;
  int frame_size() const;
  void clear_frame();
  ::webrtc::audioproc::Test_Frame* mutable_frame(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >*
      mutable_frame();
  const ::webrtc::audioproc::Test_Frame& frame(int index) const;
  ::webrtc::audioproc::Test_Frame* add_frame();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >&
      frame() const;

  // repeated .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
  int echo_metrics_size() const;
  void clear_echo_metrics();
  ::webrtc::audioproc::Test_EchoMetrics* mutable_echo_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics >*
      mutable_echo_metrics();
  const ::webrtc::audioproc::Test_EchoMetrics& echo_metrics(int index) const;
  ::webrtc::audioproc::Test_EchoMetrics* add_echo_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics >&
      echo_metrics() const;

  // repeated .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
  int delay_metrics_size() const;
  void clear_delay_metrics();
  ::webrtc::audioproc::Test_DelayMetrics* mutable_delay_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics >*
      mutable_delay_metrics();
  const ::webrtc::audioproc::Test_DelayMetrics& delay_metrics(int index) const;
  ::webrtc::audioproc::Test_DelayMetrics* add_delay_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics >&
      delay_metrics() const;

  // optional int32 num_reverse_channels = 1;
  bool has_num_reverse_channels() const;
  void clear_num_reverse_channels();
  ::PROTOBUF_NAMESPACE_ID::int32 num_reverse_channels() const;
  void set_num_reverse_channels(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_input_channels = 2;
  bool has_num_input_channels() const;
  void clear_num_input_channels();
  ::PROTOBUF_NAMESPACE_ID::int32 num_input_channels() const;
  void set_num_input_channels(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 num_output_channels = 3;
  bool has_num_output_channels() const;
  void clear_num_output_channels();
  ::PROTOBUF_NAMESPACE_ID::int32 num_output_channels() const;
  void set_num_output_channels(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 sample_rate = 4;
  bool has_sample_rate() const;
  void clear_sample_rate();
  ::PROTOBUF_NAMESPACE_ID::int32 sample_rate() const;
  void set_sample_rate(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 analog_level_average = 6;
  bool has_analog_level_average() const;
  void clear_analog_level_average();
  ::PROTOBUF_NAMESPACE_ID::int32 analog_level_average() const;
  void set_analog_level_average(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 max_output_average = 7;
  bool has_max_output_average() const;
  void clear_max_output_average();
  ::PROTOBUF_NAMESPACE_ID::int32 max_output_average() const;
  void set_max_output_average(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 has_voice_count = 9;
  bool has_has_voice_count() const;
  void clear_has_voice_count();
  ::PROTOBUF_NAMESPACE_ID::int32 has_voice_count() const;
  void set_has_voice_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 is_saturated_count = 10;
  bool has_is_saturated_count() const;
  void clear_is_saturated_count();
  ::PROTOBUF_NAMESPACE_ID::int32 is_saturated_count() const;
  void set_is_saturated_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional float rms_dbfs_average = 13;
  bool has_rms_dbfs_average() const;
  void clear_rms_dbfs_average();
  float rms_dbfs_average() const;
  void set_rms_dbfs_average(float value);

  // optional float ns_speech_probability_average = 14;
  bool has_ns_speech_probability_average() const;
  void clear_ns_speech_probability_average();
  float ns_speech_probability_average() const;
  void set_ns_speech_probability_average(float value);

  // optional bool use_aec_extended_filter = 15;
  bool has_use_aec_extended_filter() const;
  void clear_use_aec_extended_filter();
  bool use_aec_extended_filter() const;
  void set_use_aec_extended_filter(bool value);

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_Frame > frame_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics > echo_metrics_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics > delay_metrics_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_reverse_channels_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_input_channels_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_output_channels_;
  ::PROTOBUF_NAMESPACE_ID::int32 sample_rate_;
  ::PROTOBUF_NAMESPACE_ID::int32 analog_level_average_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_output_average_;
  ::PROTOBUF_NAMESPACE_ID::int32 has_voice_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 is_saturated_count_;
  float rms_dbfs_average_;
  float ns_speech_probability_average_;
  bool use_aec_extended_filter_;
  friend struct ::TableStruct_unittest_2eproto;
};
// -------------------------------------------------------------------

class OutputData :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audioproc.OutputData) */ {
 public:
  OutputData();
  virtual ~OutputData();

  OutputData(const OutputData& from);
  OutputData(OutputData&& from) noexcept
    : OutputData() {
    *this = ::std::move(from);
  }

  inline OutputData& operator=(const OutputData& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputData& operator=(OutputData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const OutputData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OutputData* internal_default_instance() {
    return reinterpret_cast<const OutputData*>(
               &_OutputData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OutputData& a, OutputData& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OutputData* New() const final {
    return CreateMaybeMessage<OutputData>(nullptr);
  }

  OutputData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OutputData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const OutputData& from);
  void MergeFrom(const OutputData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OutputData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "webrtc.audioproc.OutputData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // repeated .webrtc.audioproc.Test test = 1;
  int test_size() const;
  void clear_test();
  ::webrtc::audioproc::Test* mutable_test(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test >*
      mutable_test();
  const ::webrtc::audioproc::Test& test(int index) const;
  ::webrtc::audioproc::Test* add_test();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test >&
      test() const;

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.OutputData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test > test_;
  friend struct ::TableStruct_unittest_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Test_Frame

// -------------------------------------------------------------------

// Test_EchoMetrics

// optional float echo_return_loss = 1;
inline bool Test_EchoMetrics::has_echo_return_loss() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test_EchoMetrics::clear_echo_return_loss() {
  echo_return_loss_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Test_EchoMetrics::echo_return_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.echo_return_loss)
  return echo_return_loss_;
}
inline void Test_EchoMetrics::set_echo_return_loss(float value) {
  _has_bits_[0] |= 0x00000001u;
  echo_return_loss_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.EchoMetrics.echo_return_loss)
}

// optional float echo_return_loss_enhancement = 2;
inline bool Test_EchoMetrics::has_echo_return_loss_enhancement() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test_EchoMetrics::clear_echo_return_loss_enhancement() {
  echo_return_loss_enhancement_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Test_EchoMetrics::echo_return_loss_enhancement() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.echo_return_loss_enhancement)
  return echo_return_loss_enhancement_;
}
inline void Test_EchoMetrics::set_echo_return_loss_enhancement(float value) {
  _has_bits_[0] |= 0x00000002u;
  echo_return_loss_enhancement_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.EchoMetrics.echo_return_loss_enhancement)
}

// optional float divergent_filter_fraction = 3;
inline bool Test_EchoMetrics::has_divergent_filter_fraction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test_EchoMetrics::clear_divergent_filter_fraction() {
  divergent_filter_fraction_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Test_EchoMetrics::divergent_filter_fraction() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.divergent_filter_fraction)
  return divergent_filter_fraction_;
}
inline void Test_EchoMetrics::set_divergent_filter_fraction(float value) {
  _has_bits_[0] |= 0x00000004u;
  divergent_filter_fraction_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.EchoMetrics.divergent_filter_fraction)
}

// optional float residual_echo_likelihood = 4;
inline bool Test_EchoMetrics::has_residual_echo_likelihood() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test_EchoMetrics::clear_residual_echo_likelihood() {
  residual_echo_likelihood_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Test_EchoMetrics::residual_echo_likelihood() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.residual_echo_likelihood)
  return residual_echo_likelihood_;
}
inline void Test_EchoMetrics::set_residual_echo_likelihood(float value) {
  _has_bits_[0] |= 0x00000008u;
  residual_echo_likelihood_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.EchoMetrics.residual_echo_likelihood)
}

// optional float residual_echo_likelihood_recent_max = 5;
inline bool Test_EchoMetrics::has_residual_echo_likelihood_recent_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Test_EchoMetrics::clear_residual_echo_likelihood_recent_max() {
  residual_echo_likelihood_recent_max_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float Test_EchoMetrics::residual_echo_likelihood_recent_max() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.EchoMetrics.residual_echo_likelihood_recent_max)
  return residual_echo_likelihood_recent_max_;
}
inline void Test_EchoMetrics::set_residual_echo_likelihood_recent_max(float value) {
  _has_bits_[0] |= 0x00000010u;
  residual_echo_likelihood_recent_max_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.EchoMetrics.residual_echo_likelihood_recent_max)
}

// -------------------------------------------------------------------

// Test_DelayMetrics

// optional int32 median = 1;
inline bool Test_DelayMetrics::has_median() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test_DelayMetrics::clear_median() {
  median_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Test_DelayMetrics::median() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.DelayMetrics.median)
  return median_;
}
inline void Test_DelayMetrics::set_median(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  median_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.DelayMetrics.median)
}

// optional int32 std = 2;
inline bool Test_DelayMetrics::has_std() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test_DelayMetrics::clear_std() {
  std_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Test_DelayMetrics::std() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.DelayMetrics.std)
  return std_;
}
inline void Test_DelayMetrics::set_std(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  std_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.DelayMetrics.std)
}

// -------------------------------------------------------------------

// Test

// optional int32 num_reverse_channels = 1;
inline bool Test::has_num_reverse_channels() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test::clear_num_reverse_channels() {
  num_reverse_channels_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Test::num_reverse_channels() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.num_reverse_channels)
  return num_reverse_channels_;
}
inline void Test::set_num_reverse_channels(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  num_reverse_channels_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.num_reverse_channels)
}

// optional int32 num_input_channels = 2;
inline bool Test::has_num_input_channels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test::clear_num_input_channels() {
  num_input_channels_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Test::num_input_channels() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.num_input_channels)
  return num_input_channels_;
}
inline void Test::set_num_input_channels(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_input_channels_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.num_input_channels)
}

// optional int32 num_output_channels = 3;
inline bool Test::has_num_output_channels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test::clear_num_output_channels() {
  num_output_channels_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Test::num_output_channels() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.num_output_channels)
  return num_output_channels_;
}
inline void Test::set_num_output_channels(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  num_output_channels_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.num_output_channels)
}

// optional int32 sample_rate = 4;
inline bool Test::has_sample_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test::clear_sample_rate() {
  sample_rate_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Test::sample_rate() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.sample_rate)
  return sample_rate_;
}
inline void Test::set_sample_rate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  sample_rate_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.sample_rate)
}

// repeated .webrtc.audioproc.Test.Frame frame = 5;
inline int Test::frame_size() const {
  return frame_.size();
}
inline void Test::clear_frame() {
  frame_.Clear();
}
inline ::webrtc::audioproc::Test_Frame* Test::mutable_frame(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.frame)
  return frame_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >*
Test::mutable_frame() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.frame)
  return &frame_;
}
inline const ::webrtc::audioproc::Test_Frame& Test::frame(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.frame)
  return frame_.Get(index);
}
inline ::webrtc::audioproc::Test_Frame* Test::add_frame() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.frame)
  return frame_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >&
Test::frame() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.frame)
  return frame_;
}

// optional int32 analog_level_average = 6;
inline bool Test::has_analog_level_average() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Test::clear_analog_level_average() {
  analog_level_average_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Test::analog_level_average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.analog_level_average)
  return analog_level_average_;
}
inline void Test::set_analog_level_average(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  analog_level_average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.analog_level_average)
}

// optional int32 max_output_average = 7;
inline bool Test::has_max_output_average() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Test::clear_max_output_average() {
  max_output_average_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Test::max_output_average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.max_output_average)
  return max_output_average_;
}
inline void Test::set_max_output_average(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  max_output_average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.max_output_average)
}

// optional int32 has_voice_count = 9;
inline bool Test::has_has_voice_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Test::clear_has_voice_count() {
  has_voice_count_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Test::has_voice_count() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.has_voice_count)
  return has_voice_count_;
}
inline void Test::set_has_voice_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  has_voice_count_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.has_voice_count)
}

// optional int32 is_saturated_count = 10;
inline bool Test::has_is_saturated_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Test::clear_is_saturated_count() {
  is_saturated_count_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Test::is_saturated_count() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.is_saturated_count)
  return is_saturated_count_;
}
inline void Test::set_is_saturated_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  is_saturated_count_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.is_saturated_count)
}

// repeated .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
inline int Test::echo_metrics_size() const {
  return echo_metrics_.size();
}
inline void Test::clear_echo_metrics() {
  echo_metrics_.Clear();
}
inline ::webrtc::audioproc::Test_EchoMetrics* Test::mutable_echo_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics >*
Test::mutable_echo_metrics() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.echo_metrics)
  return &echo_metrics_;
}
inline const ::webrtc::audioproc::Test_EchoMetrics& Test::echo_metrics(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_.Get(index);
}
inline ::webrtc::audioproc::Test_EchoMetrics* Test::add_echo_metrics() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_EchoMetrics >&
Test::echo_metrics() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.echo_metrics)
  return echo_metrics_;
}

// repeated .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
inline int Test::delay_metrics_size() const {
  return delay_metrics_.size();
}
inline void Test::clear_delay_metrics() {
  delay_metrics_.Clear();
}
inline ::webrtc::audioproc::Test_DelayMetrics* Test::mutable_delay_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics >*
Test::mutable_delay_metrics() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.Test.delay_metrics)
  return &delay_metrics_;
}
inline const ::webrtc::audioproc::Test_DelayMetrics& Test::delay_metrics(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_.Get(index);
}
inline ::webrtc::audioproc::Test_DelayMetrics* Test::add_delay_metrics() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test_DelayMetrics >&
Test::delay_metrics() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.Test.delay_metrics)
  return delay_metrics_;
}

// optional float rms_dbfs_average = 13;
inline bool Test::has_rms_dbfs_average() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Test::clear_rms_dbfs_average() {
  rms_dbfs_average_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float Test::rms_dbfs_average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.rms_dbfs_average)
  return rms_dbfs_average_;
}
inline void Test::set_rms_dbfs_average(float value) {
  _has_bits_[0] |= 0x00000100u;
  rms_dbfs_average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.rms_dbfs_average)
}

// optional float ns_speech_probability_average = 14;
inline bool Test::has_ns_speech_probability_average() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Test::clear_ns_speech_probability_average() {
  ns_speech_probability_average_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float Test::ns_speech_probability_average() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.ns_speech_probability_average)
  return ns_speech_probability_average_;
}
inline void Test::set_ns_speech_probability_average(float value) {
  _has_bits_[0] |= 0x00000200u;
  ns_speech_probability_average_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.ns_speech_probability_average)
}

// optional bool use_aec_extended_filter = 15;
inline bool Test::has_use_aec_extended_filter() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Test::clear_use_aec_extended_filter() {
  use_aec_extended_filter_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool Test::use_aec_extended_filter() const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.Test.use_aec_extended_filter)
  return use_aec_extended_filter_;
}
inline void Test::set_use_aec_extended_filter(bool value) {
  _has_bits_[0] |= 0x00000400u;
  use_aec_extended_filter_ = value;
  // @@protoc_insertion_point(field_set:webrtc.audioproc.Test.use_aec_extended_filter)
}

// -------------------------------------------------------------------

// OutputData

// repeated .webrtc.audioproc.Test test = 1;
inline int OutputData::test_size() const {
  return test_.size();
}
inline void OutputData::clear_test() {
  test_.Clear();
}
inline ::webrtc::audioproc::Test* OutputData::mutable_test(int index) {
  // @@protoc_insertion_point(field_mutable:webrtc.audioproc.OutputData.test)
  return test_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test >*
OutputData::mutable_test() {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audioproc.OutputData.test)
  return &test_;
}
inline const ::webrtc::audioproc::Test& OutputData::test(int index) const {
  // @@protoc_insertion_point(field_get:webrtc.audioproc.OutputData.test)
  return test_.Get(index);
}
inline ::webrtc::audioproc::Test* OutputData::add_test() {
  // @@protoc_insertion_point(field_add:webrtc.audioproc.OutputData.test)
  return test_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::webrtc::audioproc::Test >&
OutputData::test() const {
  // @@protoc_insertion_point(field_list:webrtc.audioproc.OutputData.test)
  return test_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace audioproc
}  // namespace webrtc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_unittest_2eproto
